import os
import sys
import shutil
import datetime
from typing import List, Optional
from Modules.auxiliary_functions import Priority

class Manipulations(Priority):
    """
    FIXME

    """
    def __init__(self,
                 name='test',
                 run_path: Optional[str] = None,
                 new_path: Optional[str] = None,
                 base_path: Optional[str] = None,
                 dir_path: Optional[str] = None,):
        self.name = name
        self.paths = {'new': new_path,
                        'base': base_path,
                        'run': run_path,
                        'dir': dir_path}
        self.names_cases = {'new': None,
                            'base': None,
                            'run': None}
        super().__init__(paths=self.paths, names_cases=self.names_cases)


    def __repr__(self):
        return f"Name of manipulation node ({self.name}, run path {self.paths['run']}, base path " \
               f"{self.paths['base']}, new path {self.paths['new']})"

    def __str__(self):
        return f"Name of manipulation node ({self.name}, runpath {self.paths['run']}, basepath " \
               f"{self.paths['base']}, newPath {self.paths['new']})"

    def duplicate_case(self,
                       base_path: Optional[str] = None,
                       new_path: Optional[str] = None,
                       path_keys: tuple = ('basePath', 'newPath'),
                       name_keys: tuple = ('baseName', 'newName'),
                       mode: str = 'copy') -> None:
        """The function creates copy of the base case.
           pathBaseCase is the path of base case that will be copied by the function
           pathNewCase is the path of new case that will be created by the function
           mode defines how the procedure of copying will be done.
                   a) rewrite mode is the mode when folder of new case already being existed, then the folder
                   will delited by the function and base case folder will be copied to the folder being the same name
                   b) copy mode is the mode when folder of new case already being existed, then the folder will be copied
                   to the folder being old name with prefix of current time of copying. And new case will be copied
                    to folder being path of pathNewCase variables."""


        base_path, new_path = self._priority_path(base_path, new_path)

        self.checkExistence(base_path, new_path)

        if mode == 'rewrite':
                print(f'The folder {os.path.basename(new_path)}  is exist. The script run the rewrite mode')
                shutil.rmtree(new_path)
                shutil.copytree(base_path, new_path)
        elif mode == 'copy':
                print(f'The folder {os.path.basename(new_path)}  is exist. The script run the copy mode')
                now = datetime.datetime.now()
                old_file = new_path + '_' + 'old' + '_' + now.strftime("%d-%m-%Y %H:%M")
                try:
                    shutil.move(new_path, old_file)
                    self.oldNameCase = os.path.basename(old_file)
                except shutil.Error:
                    print('You run the script is often. There is exception old case')
                shutil.copytree(base_path, new_path)
        else:
                shutil.copytree(base_path, new_path)
        self.paths[path_keys[0]] = base_path
        self.paths[path_keys[1]] = new_path
        self.names_cases[name_keys[0]] = os.path.basename(base_path)
        self.names_cases[path_keys[1]] = os.path.basename(new_path)

    def create_name(self, *case_names, name_base='', name_key='new', splitter='_'):
        """The function serves to create two variables of base and new case paths.
        The name of new case is generated by special algorithm realized in the fucntion.
        The name will be created by adding variables of the list namesNewCase to base case folder name. The variables
        will be seprated by special sympol (spliter) to name of the folder.
         Variables:
                    *namesNewCase is a number of variables, which will be added to name of new case
                    baseCase is the folder name of base case
                    splitter is the variables defending the for separation in folder name of new case """
        for addName in case_names:
            name_base += splitter + str(addName)

        self.names_cases[name_key] = name_base
        return self.names_cases[name_key]

    def create_path_dir(self, dirname=None, case_name=None, path_key='new'):
        """The function creates the path using directory and name of case
        Variables
        dirname is the path of directory where new folder of case put
        newCaseName is the name of new case

        newPath is the path of new case
        """

        self.paths[path_key] = os.path.join(self.priority_path(dirname, path_key='dir'), case_name)
        return self.paths[path_key]

    def change_path(self, new_path: str, pat_key: str = 'newPath'):
        """The function is used for changing existent path by name
        Input variables
        path is new given path
        key is the name of variables of key for dictionary of addtionals pathes"""
        if pat_key in self.paths.keys():
            self.paths[pat_key] = new_path
        else:
            print('Error the key of path is not exist!')

    def create_path(self, path, path_key='testPath'):
        """The function is used to create your own path
        The created path will be written into dictionary self.addtionaldictionary with key  = name
        Input path is path of your new given path
        name is the key of dictionary storaged all addtional pathes"""
        self.paths[path_key] = path


    def get_path(self, path_key):
        """The methods gives back path acording givven name or key
        Input:
        key is the name of class variables consisting pathes or key of dictionary with pathes """

        #self.check_path_key(path_key)
        self.check_key(path_key, self.paths)
        return self.paths[path_key]

    def get_name(self, name_key):
        """The methods gives back path acording givven name or key
        Input:
        key is the name of class variables consisting pathes or key of dictionary with pathes """
        if name_key in self.names_cases.keys():
            print(self.names_cases[name_key])
            return self.names_cases[name_key]
        else:
            print('Error: The given name of key with pathes is not exist!')


    def checkExistence(self, basePath, newPath):
        """The method supports to find out existing gotten pathes
        If one of the gotten pathes is not exist, program is interupted
        """

        if not os.path.exists(basePath):
            sys.exit('Error: The base case is not exist in the directory!!!')
        elif not os.path.exists(newPath):
            dirname, newCaseName = os.path.split(newPath)
            if os.path.exists(dirname):
                os.mkdir(f'{newPath}')
            else:
                sys.exit(f'Error: The new path {dirname} is not exist !!!')


    def _priority_path(self, base_path, new_path):
        """The method is used for selection of given path
        the first priority is given path by methods
        the second priority is given path by class constructor
        If both path is None, the program is interupted
        Input :
        basePath, newPath is checkoing pathes
        Output:
        retrunBasePath, returnNewPath is selected pathes acording priority
        """

        if base_path == None:
            if self.paths['base'] != None:
                retrunBasePath = self.paths['base']
            else:
                sys.exit('Error: You do not enter the base path!!!')
        else:
            retrunBasePath = base_path

        if new_path == None:
            if self.paths['new'] != None:
                returnNewPath = self.paths['new']
            else:
                sys.exit('Error: You do not enter the new path!!!')
        else:
            returnNewPath = new_path

        return retrunBasePath, returnNewPath
