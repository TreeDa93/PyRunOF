import os
import pathlib as pl
from Modules.auxiliary_functions import Priority, Files
from typing import List, Optional, Dict, Any


class Information:
    """
    elmer_info = {'general':{path: 'etc/home ...', name: 'magnetic.sif'
                'additional1':{path: 'etc/home/new1 ...', name2: 'magnetic2.sif'
                'general':{path: 'etc/home/new3 ...', name3: 'magnetic3.sif'
                }
    """

    def __init__(self, info_key: Optional[str] = 'general',
                 case_path: Optional[str] = None):
        self.info = dict.fromkeys([info_key], dict(path=pl.Path(case_path)))


    def get_name(self, name_key: str, info_key=None) -> str:
        """The method returns the name according given key
        Input:
        key is the name of class variables consisting pathes or key of dictionary with pathes """
        return Priority.name(name_key, self.info[self.get_key(info_key)]['case_names'])

    def set_path(self, path_case: Optional[str] = pl.Path.cwd(),
                 info_key: Optional[str] = None):
        info_key = self.get_key(info_key)
        self.info[info_key]['paths'] = path_case

    def create_name(self, *case_names: List[str],
                    name_base: str = '',
                    name_key: Optional[str] = 'new',
                    splitter: Optional[str] = '_',
                    only_base: Optional[bool] = False,
                    info_key=None) -> str:
        """The function serves to create two variables of base and new case paths.
        The name of new case is generated by special algorithm realized in the fucntion.
        The name will be created by adding variables of the list namesNewCase to base case folder name. The variables
        will be seprated by special sympol (spliter) to name of the folder.
         Variables:
                    *namesNewCase is a number of variables, which will be added to name of new case
                    baseCase is the folder name of base case
                splitter is the variables defending the for separation in folder name of new case
                only_base is the flat to crete name using only base part of name.

                """

        if only_base is True:
            self.info[self.get_key(info_key)]['case_names'][name_key] = name_base
            return name_base
        else:
            for addName in case_names:
                name_base += splitter + str(addName)

            self.info[self.get_key(info_key)]['case_names'][name_key] = name_base

    def create_path_dir(self, dir_path: Optional[str] = None,
                        dir_path_key: Optional[str] = 'dir',
                        case_name: Optional[str] = None,
                        name_key: Optional[str] = None,
                        path_key: Optional[str] = 'new',
                        info_key=None) -> str:
        """The function creates the path using directory and name of case
        Variables
        dirname is the name of directory where new folder of case put
        newCaseName is the name of new case

        newPath is the name of new case
        """
        cur_path = Priority.path(dir_path, self.info[self.get_key(info_key)]['paths'], path_key=dir_path_key)
        cur_name = Priority.name(case_name, self.info[self.get_key(info_key)]['case_names'], name_key=name_key)
        self.info[self.get_key(info_key)]['paths'][path_key] = pl.Path(cur_path) / cur_name

    def create_path(self, path, path_key='testPath', info_key=None):
        """

        Args:
            path:
            path_key:
            info_key:

        Returns:
                None
        """
        self.info[self.get_key(info_key)]['paths'][path_key] = path

    def change_path(self, new_path: str, path_key: str = 'newPath') -> None:
        """

        Args:
            new_path:
            path_key:

        Returns:
                None
        """
        if path_key in self.info[self.info_key]['paths'].keys():
            self.info[self.info_key]['paths'][path_key] = new_path
        else:
            print('Error the key of name is not exist!')



    def get_path(self, path_key: str, info_key=None) -> str:
        """
        The function return path form info by key!
        Args:
            path_key: key for path
            info_key: key for info dictionary

        Returns:
                path corresponding to the key
        """

        return Priority.path(None, self.info[self.get_key(info_key)]['paths'], path_key=path_key)

    def set_new_parameter(self, parameter: Any,
                          info_key: Optional[str] = None,
                          parameter_name: Optional[str] = 'new_parameter'):
        """
        FIXME
        Args:
            parameter:
            info_key:
            parameter_name:

        Returns:

        """
        info_key = self.get_key(info_key)
        self.info[info_key][parameter_name] = parameter

    def get_any_parameter(self, param_key: str,
                          info_key: Optional[str] = None,
                          ) -> Any:
        """
        FIXME
        Args:
            param_key:
            info_key:

        Returns:

        """
        info_key = self.get_key(info_key)
        return self.info[info_key][param_key]

    def get_general_key(self):
        """
        FIXME
        Returns:

        """
        return list(self.info.keys())[0]

    def get_key(self, key):
        """
        Проверка задания ключа. Если ключ не задан берется ключ
        из аттрибута класса
        Args:
            key:

        Returns:

        """
        if key is None:
            return self.get_general_key()
        else:
            return key

    def get_constant_path(self, case_path: str, info_key: Optional[str] = None):
        """
        FIXME
        Args:
            case_path:
            info_key:

        Returns:

        """
        where = self.info[self.get_key(info_key)]
        return Priority.path_add_folder(case_path, where, 'constant', path_key='case_path')

    def get_system_path(self, case_path: str, info_key: Optional[str] = None):
        """
        FIXME
        Args:
            case_path:
            info_key:

        Returns:

        """
        where = self.info[self.get_key(info_key)]
        return Priority.path_add_folder(case_path, where, 'system', path_key='case_path')

    def get_any_folder_path(self, case_path: str, info_key: Optional[str] = None, folder: str ='0'):
        """
        FIXME
        Args:
            case_path:
            info_key:
            folder:

        Returns:

        """
        where = self.info[self.get_key(info_key)]
        return Priority.path_add_folder(case_path, where, folder, path_key='path')

    def find_all_sif(self, path_case: Optional[str] = None,
                     info_key: Optional[str] = None) -> list:
        """
        FIXME
        Args:
            path_case:
            info_key:

        Returns:

        """
        info_key = self.get_key(info_key)
        path_case = Priority.path(path_case, self.info[info_key], path_key='path')

        return list(path_case.glob('**/*.sif'))

    def find_all_zero_files(self, path_case: Optional[str] = None,
                     info_key: Optional[str] = None) -> list:
        """
        The method is served to find all files in zero folder of OpenFoam case,
        for example U, p etc.
        FIXME
        Args:
            path_case: the path of openfoam case
            info_key:

        Returns:
                string
        """
        info_key = self.get_key(info_key)
        path_case = Priority.path(path_case, self.info[info_key], path_key='case_path')
        zero_folder_path = path_case / '0'
        return list(zero_folder_path.glob('**/*.sif'))

    def collect_information(self, *class_set, key_info=None):
        for c_cls in class_set:
            for key, val in c_cls.info.items():
                if type(val) is not dict:
                    self.info[key] = val
                else:
                    self.info[key].update(val)

    def __init_ps__(self, info_key: Optional[str] = 'general',
                    fun=None,
                    json_path=None
                    ):
        self.info = dict.fromkeys([info_key], dict(fun=fun,
                                                   json_path=json_path))


    def __init_elmer__(self, info_key: Optional[str] = 'general',
                       case_path: Optional[str] = None,
                       sif_name: Optional[str] = None):
        self.info = dict.fromkeys([info_key], dict(case_path=self._check_type_path(case_path),
                                                   name=sif_name))

    def __init_constant__(self, info_key: Optional[str] = 'general',
                          case_path: Optional[str] = None,
                          lib_path: Optional[str] = None):
        self.info = dict.fromkeys([info_key], dict(case_path=self._check_type_path(case_path),
                                                   lib_path=self._check_type_path(lib_path)))

    def __init_iv__(self, info_key: Optional[str] = 'general',
                    case_path: Optional[str] = None):
        self.info = dict.fromkeys([info_key],
                                  dict(case_path=self._check_type_path(case_path)))

    def __init_mesh__(self, info_key: Optional[str] = 'general',
                       case_path: Optional[str] = None,
                       e_mesh: Optional[str] = None):
        # FIXME
        self.info = dict.fromkeys([info_key], dict(case_path=self._check_type_path(case_path),
                                                   elmer_mesh_name=e_mesh))

    def __init_ps__(self, info_key: Optional[str] = 'general',
                       case_path: Optional[str] = None,
                      fun=None):
        # FIXME
        self.info = dict.fromkeys([info_key], dict(path=self._check_type_path(case_path),
                                                   fun=fun))

    def __init_system__(self,info_key: Optional[str] = 'general', case_path: Optional[str] = None):
        self.info = dict.fromkeys([info_key], dict(path=self._check_type_path(case_path)))

    def __init_runner__(self, info_key: Optional[str] = 'general',
                        case_path: Optional[str] = None,
                        solver: Optional[str] = 'pimpleFoam',
                        mode: Optional[str] = 'common'):
        self.info = dict.fromkeys([info_key], dict(case_path=self._check_type_path(case_path),
                                                   solver=solver,
                                                   mode=mode,
                                                   pyFoam=False,
                                                   log=False,
                                                   cores={'OF': None, 'Elmer': None}))

    def __init_manipulation__(self, info_key: Optional[str] = 'general',
                              dir_path: Optional[str] = None):
        self.info_key = info_key
        self.info = dict.fromkeys([info_key], dict(paths={"dir": self._check_type_path(dir_path)},
                                                   case_names={}))

    @staticmethod
    def _check_type_path(path):
        if type(path) in [str, os.PathLike, pl.PosixPath, pl.WindowsPath]:
            return pl.Path(path)
        else:
            return None

    @staticmethod
    def _check_prefix_sif(sif_name):
        if '.sif' not in sif_name:
            sif_name += '.sif'
        return sif_name

